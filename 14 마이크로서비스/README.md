# 14 마이크로서비스

- 현대 시스템 요구사항: 빠른 변화, 확장, 클라우드 컴퓨팅 -> 이를 위한 **유연성**이 핵심
- 기업들은 이를 위해 모놀리식 아키텍처를 쪼개기 시작했습니다.
- 하지만 대부분의 결과물은 더 깨지기 쉽고, 투박하고, 비싼, 분산된, 커다란 진흙덩어리였습니다.
- 사람들은 때때로 바운디드 컨텍스트와 마이크로서비스를 혼용하기도 합니다.

## 서비스란 무엇인가?

미리 정의된 인터페이스 (pre-defined interface)

- 다들 잘 아시다시피, 데이터를 넣고 빼기 위한 인터페이스입니다.
- 동기식: 요청/응답 모델
- 비동기식: 이벤트를 제공/사용하는 모델

외부에 노출되는 시스템 영역 (front door)

- [랜디 숍의 발표 Managing Data in Microservices](https://www.infoq.com/presentations/microservices-data-centric/)에 따르면 서비스의 인터페이스는 front door에 있어야 합니다.
- 서비스를 출입하는 데이터는 모두 이 front door를 통합니다.
- 잘 표현된 인터페이스는 서비스의 기능을 명확하게 설명합니다. (self descriptive)

## 마이크로서비스란 무엇인가?

- 간단합니다. 자신의 마이크로 퍼블릭 인터페이스에 의해 정의되는 서비스입니다.
- 마이크로 퍼블릭 인터페이스를 통해 서비스의 기능과 그 서비스가 연동하는 다른 시스템 컴포넌트를 쉽게 이해할 수 있습니다.
- 기능을 줄이면 변경될 이유가 줄어들고, 개발 관리, 확장에 자율성이 생깁니다.
- 마이크로서비스는 자신의 데이터베이스를 노출하지 않습니다. SQL로 접근하면 인터페이스가 무한히 늘어나기 때문입니다. 데이터는 간단하고 연동 지향적인 퍼블릭 인터페이스로만 접근할 수 있습니다.

### 서비스형 메서드

일단 초보적으로, 서비스 인터페이스가 단일 메서드만 갖도록 제한해 분해해봅시다. (그림 14-3)

- 서로의 데이터베이스에 직접 접근할 수 없습니다. 하지만 데이터 접근을 위한 퍼블릭 인터페이스가 없습니다. 따라서 연동 관련 관심사를 처리하기 위해 인터페이스를 확장해야 합니다. (그림 14-4)
  - 독자: 이 확장한 인터페이스는 퍼블릭은 아니고, 마이크로서비스 간 전용으로 보입니다. 시스템에는 노출되어 있지 않지만, 마이크로서비스끼리는 접근할 수 있는 것이죠.
- 오로지 1개씩의 메서드가 흩어져있으니, 의존 관계 및 데이터 흐름이 매우 복잡합니다. 현재의 시스템은 단순히 분산되어있을 뿐인 커다란 진흙 덩어리나 다름없습니다.
- 이렇게 작게 분해하면 front door는 최소화되지만, 전체적인 시스템 구현을 위해 각 서비스에 수많은 "스태프 전용" 출입구가 필요합니다.

### 설계 목표

- 이렇게 쪼개는 건 그냥 불가능합니다. 서비스는 서로 협력해야 하므로, 연동을 위한 퍼블릭 메서드를 가진 퍼블릭 인터페이스가 있어야 했습니다.
- 위의 설계는 전투(서비스)에서 이겼습니다. 각 서비스는 훨씬 간단해졌습니다. 반면에 전쟁(전체 시스템)에서 졌습니다. 전체 시스템은 훨씬 복잡해졌습니다.

마이크로서비스 아키텍처의 목표는 **유연한 시스템**입니다.

- 단일 컴포넌트에만 집중하고 연동을 무시하는 것은 **시스템의 정의**에 부합하지 않습니다.
  - "함께 작동하는 연동된 것 또는 디바이스"
  - "특정 목적을 위해 함께 사용되는 컴퓨터 장비 및 프로그램"

### 시스템의 복잡성

- 로컬 복잡성: 각각의 개별 마이크로서비스의 복잡성
- 글로벌 복잡성: 전체 시스템 복잡성. 서비스 간의 상호작용과 의존성으로 정의됩니다.

모놀리식 모델: 글로벌 복잡성 0

- 상호작용을 없앤다는 의미입니다.
- 특정 상황에서는 효과적일 수 있습지만, 때로는 무시무시한 커다란 진흙 덩어리가 될 수도 있습니다.
- 로컬 복잡성은 가능한 최고점이 될 것입니다.

최적화 (그림 14-5)

- 로컬 복잡성만 최적화하면 어떻게 되는지는 위에서 봤습니다. 결국 하나를 잡으려면 하나를 포기해야 합니다.
- 적절한 마이크로서비스 시스템을 설계하려면 두 복잡성을 모두 적절히 최적화해야 합니다.
- 로컬 최적화: 하나를 개별적으로 최적화하는 것입니다. 즉 여기서는 두 복잡성 중 하나만 최적화하는 것입니다.
- 글로벌 최적화: **두 복잡성의 균형**을 최적화하는 것입니다.

### 깊은 서비스로서의 마이크로 서비스

용어

- 함수(function): 모듈이 해야 하는 일. 비즈니스 기능
- 로직(logic): 모듈의 비즈니스 로직. 함수를 구현하는 방법

[깊이(depth) 휴리스틱](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201) (그림 14-6)

- 사각형의 상단 끝: 모듈의 function입니다. 퍼블릭 인터페이스의 복잡성을 나타내게 됩니다.
- 너비: 기능이 폭넓은지, 아니면 제한적인지를 나타냅니다.
- 깊이(높이): 복잡성을 나타냅니다. 깊을 수록 복잡합니다.
- 면적: 비즈니스 로직의 총량입니다.
- 효과적인 모듈은 깊이가 깊습니다. 간단한 퍼블릭 인터페이스가 복잡한 로직을 내포합니다.
- 효과적이지 못한 모듈은 깊이가 얕고 복잡성이 낮습니다.

극단적인 얕은 모듈

```csharp
int AddTwoNumbers()(int a, int b) {
    return a + b;
}
```

- 메서드의 시그니처(function)와 로직이 정확히 동일합니다.
- 이런 모듈은 수많은 '유동적인 부분'을 만들어내고, 결국 오히려 시스템에 우발적 복잡성을 발생시킵니다.

### 깊은 모듈로서의 마이크로서비스

모듈과 마이크로서비스

- 마이크로서비스는 물리적 경계만을 나타냅니다.
  - 무조건 다른 프로세스를 사용하는 등, 실제로 서비스가 물리적으로 구별되어야 합니다.
- 모듈은 논리적 겨예와 물리적 경계를 모두 나타낼 수 있습니다.
- 이를 제외한 개념과 설계 원칙은 서로 동일합니다.

얕은 모듈

- 연동에 관련된 퍼블릭 메서드가 필요해집니다.
- 즉, 인터페이스가 자연스럽게 넓어지게(사각형이 얕고 넓어지게) 됩니다.

얕은 모듈이 프로젝트를 실패하게 하는 사례

- 코드 라인 수를 제한합니다.
- 서비스의 수정보다 재작성을 지향합니다.
- 전체 시스템을 등한시하고 개별 서비스에만 집중합니다.

분해의 임계치(critical point)는 중간 어딘가에 있습니다. (그림 14-7)

- 분해 0: 커다란 진흙 덩어리 모놀리식입니다. 변경 비용이 높습니다.
- 분해 시작: 일단 분해된 기능은 변경이 쉬워지므로, 변경 비용은 decrease합니다.
- 과도한 분해: 일정치를 지나도 계속 분해하면 변경 비용이 다시 increase합니다.
  - 점점 얕은 서비스가 됩니다.
  - 인터페이스가 많아지고, 통합이 필요해지므로 변경 비용이 다시 올라가게 됩니다.
- 따라서 변경 비용의 극소값은 그 사이 어딘가에 존재하게 됩니다.

이 깊은 서비스의 경계를 찾는 데 DDD가 도움을 줍니다.

## 도메인 주도 설계와 마이크로서비스의 경계

다음 중 어떤 경계가 마이크로서비스의 개념에 도움을 줄까요?

- 바운디드 컨텍스트: 모델의 경계
- 하위 도메인: 비즈니스 역량의 경계
- 애그리게이트와 밸류 오브젝트: 트랜잭션의 경계

### 바운디드 컨텍스트

마이크로서비스는 바운디드 컨택스트로 볼 수 있습니다.

- 모두 물리적 경계입니다.
- 단일 팀이 소유합니다.
- 충돌하는 모델(용어 충돌 등)은 인터페이스가 복잡해지므로 단일 서비스 내에서 구현하기 어렵습니다.

바운디드 컨택스트는 마이크로서비스가 아닙니다. 위에서부터 크기가 가장 큰 경계입니다. (그림 14-10)

- 커다란 진흙 덩어리
  - 모델의 일관성이 깨진 상태
- 바운디드 컨텍스트
  - recall: 유비쿼터스 언어 및 비즈니스 도메인 모델의 일관성이 보호되는 경계입니다.
  - 모놀리식의 유효한 경계로 볼 수 있습니다.
  - 때로는 거대한 모놀리식이 효과적인 경우도 있습니다.
- 마이크로서비스
  - 유연성을 위해 모놀리식을 적절히 쪼갠 경계
- 분산된 거대한 진흙덩어리
  - 바운디드 컨텍스트가 잘못 분해된 경우
  - 마이크로서비스가 과도하게 분해된 경우

### 애그리게이트

결론: 그러지 마세요.

- 애그리게이트는 가장 좁게 설정된 경계입니다.
- 이를 여러 물리적 서비스(마이크로서비스)나 바운디드 컨텍스트로 분해하지 마세요. (부록 A)

비즈니스 기능 단위

- 애그리게이트는 비즈니스 기능 단위입니다.
- 아까 봤듯이 마이크로서비스는 개별 서비스(기능 단위)로 하면 안 됩니다.
- 만약 애그리게이트 단위로 마이크로서비스를 구현했다면, 애그리게이트가 다른 애그리게이트와 통신이 잦을수록, 즉 서로 관계가 강할수록 얕은 개별 서비스가 되어버릴 수 있습니다. 인터페이스가 많이 필요해지기 때문입니다.
- 가끔 애그리게이트를 서비스화해 모듈형 설계를 만드는 경우도 있지만, 대체로 글로벌 복잡성이 증가합니다.

### 하위 도메인

**하위 도메인을 마이크로서비스로 만드는 것**은 안전한 휴리스틱입니다.

- 하위 도메인은 비즈니스 역량(무엇을 하는 비즈니스인지)를 설명하며, 유즈케이스의 집합을 의미합니다.
- 한 하위 도메인에 속한 유즈케이스는 강한 기능 연관성을 갖고, 유즈케이스 하나가 변경되면 다른 것도 변경될 수 있습니다.
- 하위 도메인을 설명하는 '기능'은 '로직'을 캡슐화(블랙 박스화)합니다.
- 유즈케이스가 응집될수록 그걸 블랙 박스로 감싼 모듈은 깊어집니다.
- 역으로 유즈케이스를 더 쪼개면 인터페이스는 복잡해지고 모듈은 얕아집니다.

다른 경계도 있으니 이에 집착하지는 마세요.

- 언어적 경계를 위해 더 넓은 바운디드 컨텍스트에 머물 수도 있습니다.
- 비기능적 요구사항 때문에 애그리게이트를 마이크로서비스로 만들 수도 있습니다.
- 조직의 구조와 비즈니스 전략, 비기능 요구사항에 맞게 적응시키는 것이 더 중요합니다.

## 마이크로서비스의 퍼블릭 인터페이스 압축하기

DDD는 서비스의 경계를 찾을 뿐만 아니라, 서비스를 깊게 만드는 데도 도움을 줍니다.

### 오픈 호스트 서비스

바운디드 컨텍스트 모델과 연동 모델을 분리합니다. (그림 14-12)

- 서비스 사용자에게의 영향을 최소화할 수 있습니다.
- 보통 최소한의 모델만을 노출하므로 사용자가 편안해집니다.
- 구현이 같을 때 퍼블릭 인터페이스(기능)이 간단하다면, 상대적으로(면적은 줄어드므로) 서비스가 깊이 있어지게 됩니다.

### 충돌 방지 계층

ACL은 그 자체로 하나의 서비스로 발전할 수 있습니다. (그림 14-13)

- ACL이 제공하는 퍼블릭 인터페이스는 압축된 것이므로 사용자는 편리해집니다.
- 비즈니스 복잡성과 연동의 복잡성이 관심사 분리됩니다. 연동의 복잡성을 ACL 서비스가 담당할 수 있기 때문입니다.
