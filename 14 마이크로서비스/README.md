# 14 마이크로서비스

- 현대 시스템 요구사항: 빠른 변화, 확장, 클라우드 컴퓨팅 -> 이를 위한 **유연성**이 핵심
- 기업들은 이를 위해 모놀리식 아키텍처를 쪼개기 시작했습니다.
- 하지만 대부분의 결과물은 더 깨지기 쉽고, 투박하고, 비싼, 분산된, 커다란 진흙덩어리였습니다.
- 사람들은 때때로 바운디드 컨텍스트와 마이크로서비스를 혼용하기도 합니다.

## 서비스란 무엇인가?

미리 정의된 인터페이스 (pre-defined interface)

- 다들 잘 아시다시피, 데이터를 넣고 빼기 위한 인터페이스입니다.
- 동기식: 요청/응답 모델
- 비동기식: 이벤트를 제공/사용하는 모델

외부에 노출되는 시스템 영역 (front door)

- [랜디 숍의 발표 Managing Data in Microservices](https://www.infoq.com/presentations/microservices-data-centric/)에 따르면 서비스의 인터페이스는 front door에 있어야 합니다.
- 서비스를 출입하는 데이터는 모두 이 front door를 통합니다.
- 잘 표현된 인터페이스는 서비스의 기능을 명확하게 설명합니다. (self descriptive)

## 마이크로서비스란 무엇인가?

- 간단합니다. 자신의 마이크로 퍼블릭 인터페이스에 의해 정의되는 서비스입니다.
- 마이크로 퍼블릭 인터페이스를 통해 서비스의 기능과 그 서비스가 연동하는 다른 시스템 컴포넌트를 쉽게 이해할 수 있습니다.
- 기능을 줄이면 변경될 이유가 줄어들고, 개발 관리, 확장에 자율성이 생깁니다.
- 마이크로서비스는 자신의 데이터베이스를 노출하지 않습니다. SQL로 접근하면 인터페이스가 무한히 늘어나기 때문입니다. 데이터는 간단하고 연동 지향적인 퍼블릭 인터페이스로만 접근할 수 있습니다.

### 서비스형 메서드

일단 초보적으로, 서비스 인터페이스가 단일 메서드만 갖도록 제한해 분해해봅시다. (그림 14-3)

- 서로의 데이터베이스에 직접 접근할 수 없습니다. 하지만 데이터 접근을 위한 퍼블릭 인터페이스가 없습니다. 따라서 연동 관련 관심사를 처리하기 위해 인터페이스를 확장해야 합니다. (그림 14-4)
  - 독자: 이 확장한 인터페이스는 퍼블릭은 아니고, 마이크로서비스 간 전용으로 보입니다. 시스템에는 노출되어 있지 않지만, 마이크로서비스끼리는 접근할 수 있는 것이죠.
- 오로지 1개씩의 메서드가 흩어져있으니, 의존 관계 및 데이터 흐름이 매우 복잡합니다. 현재의 시스템은 단순히 분산되어있을 뿐인 커다란 진흙 덩어리나 다름없습니다.
- 이렇게 작게 분해하면 front door는 최소화되지만, 전체적인 시스템 구현을 위해 각 서비스에 수많은 "스태프 전용" 출입구가 필요합니다.

### 설계 목표

- 이렇게 쪼개는 건 그냥 불가능합니다. 서비스는 서로 협력해야 하므로, 연동을 위한 퍼블릭 메서드를 가진 퍼블릭 인터페이스가 있어야 했습니다.
- 위의 설계는 전투(서비스)에서 이겼습니다. 각 서비스는 훨씬 간단해졌습니다. 반면에 전쟁(전체 시스템)에서 졌습니다. 전체 시스템은 훨씬 복잡해졌습니다.

마이크로서비스 아키텍처의 목표는 **유연한 시스템**입니다.

- 단일 컴포넌트에만 집중하고 연동을 무시하는 것은 **시스템의 정의**에 부합하지 않습니다.
  - "함께 작동하는 연동된 것 또는 디바이스"
  - "특정 목적을 위해 함께 사용되는 컴퓨터 장비 및 프로그램"

### 시스템의 복잡성

- 로컬 복잡성: 각각의 개별 마이크로서비스의 복잡성
- 글로벌 복잡성: 전체 시스템 복잡성. 서비스 간의 상호작용과 의존성으로 정의됩니다.

모놀리식 모델: 글로벌 복잡성 0

- 상호작용을 없앤다는 의미입니다.
- 특정 상황에서는 효과적일 수 있습지만, 때로는 무시무시한 커다란 진흙 덩어리가 될 수도 있습니다.
- 로컬 복잡성은 가능한 최고점이 될 것입니다.

최적화 (그림 14-5)

- 로컬 복잡성만 최적화하면 어떻게 되는지는 위에서 봤습니다. 결국 하나를 잡으려면 하나를 포기해야 합니다.
- 적절한 마이크로서비스 시스템을 설계하려면 두 복잡성을 모두 적절히 최적화해야 합니다.
- 로컬 최적화: 하나를 개별적으로 최적화하는 것입니다. 즉 여기서는 두 복잡성 중 하나만 최적화하는 것입니다.
- 글로벌 최적화: **두 복잡성의 균형**을 최적화하는 것입니다.

### 깊은 서비스로서의 마이크로 서비스

용어

- 함수(function): 모듈이 해야 하는 일. 비즈니스 기능
- 로직(logic): 모듈의 비즈니스 로직. 함수를 구현하는 방법

[깊이(depth) 휴리스틱](https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201) (그림 14-6)

- 사각형의 상단 끝: 모듈의 function입니다. 퍼블릭 인터페이스의 복잡성을 나타내게 됩니다.
- 너비: 기능이 폭넓은지, 아니면 제한적인지를 나타냅니다.
- 깊이(높이): 복잡성을 나타냅니다. 깊을 수록 복잡합니다.
- 면적: 비즈니스 로직의 총량입니다.
- 효과적인 모듈은 깊이가 깊습니다. 간단한 퍼블릭 인터페이스가 복잡한 로직을 내포합니다.
- 효과적이지 못한 모듈은 깊이가 얕고 복잡성이 낮습니다.

극단적인 얕은 모듈

```csharp
int AddTwoNumbers()(int a, int b) {
    return a + b;
}
```

- 메서드의 시그니처(function)와 로직이 정확히 동일합니다.
- 이런 모듈은 수많은 '유동적인 부분'을 만들어내고, 결국 오히려 시스템에 우발적 복잡성을 발생시킵니다.

### 깊은 모듈로서의 마이크로서비스

모듈과 마이크로서비스

- 마이크로서비스는 물리적 경계만을 나타냅니다.
  - 무조건 다른 프로세스를 사용하는 등, 실제로 서비스가 물리적으로 구별되어야 합니다.
- 모듈은 논리적 겨예와 물리적 경계를 모두 나타낼 수 있습니다.
- 이를 제외한 개념과 설계 원칙은 서로 동일합니다.

얕은 모듈

- 연동에 관련된 퍼블릭 메서드가 필요해집니다.
- 즉, 인터페이스가 자연스럽게 넓어지게(사각형이 얕고 넓어지게) 됩니다.

얕은 모듈이 프로젝트를 실패하게 하는 사례

- 코드 라인 수를 제한합니다.
- 서비스의 수정보다 재작성을 지향합니다.
- 전체 시스템을 등한시하고 개별 서비스에만 집중합니다.

분해의 임계치(critical point)는 중간 어딘가에 있습니다. (그림 14-7)

- 분해 0: 커다란 진흙 덩어리 모놀리식입니다. 변경 비용이 높습니다.
- 분해 시작: 일단 분해된 기능은 변경이 쉬워지므로, 변경 비용은 decrease합니다.
- 과도한 분해: 일정치를 지나도 계속 분해하면 변경 비용이 다시 increase합니다.
  - 점점 얕은 서비스가 됩니다.
  - 인터페이스가 많아지고, 통합이 필요해지므로 변경 비용이 다시 올라가게 됩니다.
- 따라서 변경 비용의 극소값은 그 사이 어딘가에 존재하게 됩니다.

이 깊은 서비스의 경계를 찾는 데 DDD가 도움을 줍니다.

## 도메인 주도 설계와 마이크로서비스의 경계
