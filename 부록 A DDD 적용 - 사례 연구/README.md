# 부록 A DDD 적용 - 사례 연구

## 다섯 가지 바운디드 컨텍스트

### 바운디드 컨텍스트 #1: 마케팅

빈약한 도메인 모델(anemic domain model) 안티패턴

- 도메인 모델에 비즈니스 로직이 거의 없고, getter와 setter 언저리만 있는 경우입니다.
- 비즈니스 로직은 거대한 서비스 계층에서 구현됩니다.
- 모든 것이 애그리게이트

성공(데드라인을 맞춘) 비결

- 강력한 유비쿼터스 언어를 고안했습니다.
- 매우 좋은 도메인 전문가들(동료들): 대화에 적극적인 사람들이고, 우리가 배우려고 하는 것을 환영합니다.

### 바운디드 컨텍스트 #2: CRM

- 여전히 하나의 모놀리스입니다.
- 애그리게이트 이름에 접두어가 계속 붙음: `CRMLead`, `MarketingLead`, ... -> 유비쿼터스 언어가 아닙니다.
- 우리는 애그리게이트를 자료구조로 설계했지만, 실제 애그리게이트는 시스템 데이터의 일관성을 보호해야 합니다.

#### 재설계

- 바운디드 컨텍스트를 둘로 나누고, 유비쿼터스 언어를 보호했습니다.
- 빈약한 도메인 모델을 제거했습니다.

그럼에도 불구하고 여전히 오래 걸렸습니다.

- 트랜잭션 경계가 올바르지 않았습니다.
- 몇 가지 후보 모델을 골라서 평가해보지 못했습니다.

결국 최악의 선택: SQL로 비즈니스 로직 구현

- stored procedure: DB의 함수라고 생각하면 됩니다.
- 이로 인해 많은 피해를 봤습니다.

#### 바벨탑 2.0

'리드' 비즈니스 엔티티를 암시적인 바운디드 컨텍스트로, 하지만...

- 모델 일관성 x
- 정보 공유 x
- 코드 중복 o
- 결국 최악의 결과인 데이터 손상까지 발생했습니다.

#### 도메인 주도 설계에 대한 폭넓은 이해

교훈

- 바운디드 컨텍스트가 유비쿼터스 언어를 보호해야 합니다.
- 적절한 도메인 모델을 이용해서 바운디드 컨텍스트를 구현해야 합니다.

### 바운디드 컨텍스트 #3: 이벤트 크런처

- 정체 모를 하위 도메인이 CRM과 마케팅을 오가고 있습니다.
- '고객 이벤트를 처리하는 프로세스'를 수정할 때 두 바운디드 컨텍스트를 모두 수정해야 합니다.

이 친구를 추출하기로 결정했습니다.

- 지원 하위 도메인으로 결정
- 계층화 아키텍처 + 트랜잭션 스크립트로 간단하게 작성

그런데 시간이 지나면서...

- 기능 요구사항 증가, 이벤트 크런처가 더 복잡해집니다.
- 결국 핵심 비즈니스 하위 도메인으로 발전했습니다.
- 근데 복잡한 비즈니스 로직을 구현하기 위해 트랜잭션 스크립트를 쓰면 무시무시한 일이 일어날 수 있습니다.
- 결국 매우 커다란 진흙 덩어리가 되었습니다.

리팩토링: 이벤트 소싱

- 다른 바운디드 컨텍스트는 '이벤트 크런처'의 이벤트를 구독하도록 했습니다.

### 바운디드 컨텍스트 #4: 보너스

- 흔한 아이디어들을 수동으로 작업하던 걸 자동화하는 도메인입니다.
- 핵심 하위 도메인은 아니었습니다. 지원 하위 도메인으로 분류되었습니다.
- 4계층(서비스 포함) 아키텍처로 구현했습니다.

자동화가 시작되니 회사의 모든 사람이 갑자기 창의적으로 변합니다.

- 니즈 급증, 기능 급증
- 어느 순간 핵심 하위 도메인으로 변합니다.
- 코드 베이스는 진흙 덩어리가 됩니다.
- 돈 관련 버그는 특히 예민하게 봐야 합니다. 매우 치명적인 손실을 야기할 수 있습니다.

#### 설계: 두 번째 시도

- 처음부터 재작성했습니다.
- 이벤트 소싱 도메인 모델을 채택했습니다.

직전 바운디드 컨텍스트처럼 발전했지만, 차이점도 있었습니다.

- 유비쿼터스 언어가 복잡함 -> 액티브 레코드로 구현이 어렵다는 것을 깨달았습니다.

여기쯤에서 DDD의 전형적인 모델을 이해합니다.

- 바운디드 컨텍스트가 유비쿼터스 언어를 보호
- 하위 도메인을 인식하고 구별해야 바운디드 컨텍스트를 나눌 수 있습니다.
- 유형에 맞는 적절한 패턴을 골라 하위 도메인을 구현해야 합니다.

### 바운디드 컨텍스트 #5: 마케팅 허브

- 새로운 수익 창출 기회 -> 핵심 하위 도메인
- 중무기 선택: 이벤트 소싱 도메인 모델, CQRS, MSA
- 서비스는 최대한 작게, 서비스마다 자체 데이터베이스, 서비스 간 동기/비동기 통신

#### 마이크로 뭐라고?

- 서비스는 작을수록 좋다고 생각했습니다.
- 규모가 커질수록 점점 복잡해지고, 기능 하나를 추가하는데 거의 모든 서비스가 동원되어야 합니다.
- 분산형 거대한 진흙 덩어리

원인: 너무 복잡한 걸 썼습니다.

- 시스템 자체가 필요 이상으로 복잡합니다.
- 우발적 복잡성: 시간이 흐르면서 자연스럽게 복잡해집니다.

## 논의

### 유비쿼터스 언어

- **유비쿼터스 언어는 신이다**
- 공유, 유지보수에 신경써야 합니다.

### 하위 도메인

- 유형 식별을 잘 해야 합니다.
- 유형이 언제 바뀔지도 모름

설계 의사결정

- 실제 설계 패턴들과 잘 매핑해야 합니다.
- 우발적 복잡성(오버 엔지니어링)을 피해야 합니다.

고충을 무시하지 마라

- 뭔가 신호가 있으면 바꾸는 걸 고려해야 합니다.

### 바운디드 컨텍스트의 경계

- !@#\$ 경계: 하나의 애그리게이트를 둘 이상의 바운디드 컨텍스트로 분할하면 !@#\$합니다.
- 결국 전략은 케바케입니다.
- 초기 경계는 도메인 지식을 모를 수록 넓게 잡아야 합니다.

## 결론

- 급박한 조건, 빠른 변화 속에서 어쨌든 출시를 해야 합니다.
