# 6장 복잡한 비즈니스 로직 다루기

복잡한 비즈니스 로직에 사용되는 도메인 모델 패턴에 대해 알아보자
#### 배경
- 전술적 도메인 주도 설계 패턴
    - 패턴 == "도메인 모델"
    - 구성 요소: Aggregate, value object, repository
        - 비즈니스 도메인의 하위 모델과 코드를 연결 짓는데 쓰이는 것

### 도메인 모델
- 복잡한 비즈니스 로직 - 복잡한 상태 전환, 항상 보호해야 하는 비즈니스 규칙, 불변성을 다룬다.
- 예시) 복잡한 지원 티켓 수명주기 로직 요구사항
    - 다양한 규칙 간에 의존성 형성
    - 모든 규칙이 지원 티켓의 수명주기 관리 로직에 영향을 준다
    - 액티브 레코드 객체 사용 -> 로직 중복 / 잘못 구현한 비즈니스 로직으로 시스템 상태 손상 야기
##### 구현
**도메인 모델이란:**
- 행동(behavior)과 데이터(data) 모두를 포함하는 도메인의 **객체 모델**.
- **구성요소**: DDD의 전술 패턴인 Aggregate, Value Object, Domain Event, Domain Service
###### 복잡성
- 이미 복잡한 도메인 비즈니스 로직 자체 -> 모델링에 사용되는 객체가 모델에 우발적 복잡성을 추가하지 말자.
- 모델에는 DB 또는 외부 시스템 구성요소의 호출 구현같은 기술적 관심사 제외
###### 유비쿼터스 언어
- 도메인 모델의 객체가 기술적 관심사가 아닌 비즈니스 로직에 집중 -> 바운디드 컨텍스트 안의 유비쿼터스 언어의 용어를 따르기 쉬워진다.
- 이 패턴은 코드에서 유비쿼터스 언어를 사용하게 한다.
--- 
### 구성요소
#### 1. Value Object
복합적인 값에 의해 식별되는 객체.
- 예시1: 색(Color)
  **특징:**
- 같은 값을 갖는 두 개 이상의 색은 존재하지 않는다.
- 같은 색의 두 인스턴스는 반드시 같은 값을 갖는다.
  -> 색을 식별하기 위한 **명시적 식별 필드**가 필요 없다. (colorId)
    - 있을 경우: colorId 비교만으로 같은 값인지 알지 못하며, 같은 값을 갖는 두개의 행을 만드는 상황을 초래한다.

예시 2: Person 클래스의 값들
- primitive type을 사용한 비즈니스 도메인 개념 표현(설계) -> 설계 위험
    - 중복된 유효성 검사 로직
    - 값이 사용되기 전 유효성 검사 로직을 호출하기 어려움
    - 유지보수가 어렵다

- Value Object 사용 - 장점
    - 명료성 향상: 짧은 변수 이름, 명확한 의도 전달
    - 유효성 검사 필요X: Value object 안에 있는 유효성 검사 로직
    - 응집된 로직: 값을 조작하는 비즈니스 로직/ 새로운 밸류 오브젝트 인스턴스 생성 로직 응집
    - 코드에서 유비쿼터스 언어를 사용하게 한다. (코드에서 비즈니스 도메인의 개념을 표현)

**구현**
- 불변 객체로 구현 : 필드 중 하나가 변경될 시 의미상 새로운 값을 생성한다.
- 동일성: id필드, 참조가 아닌 값에 기반 -> 동일성 검사 함수 오버라이드 구현 필요

예시 3: 문자열 타입 (.Net, Java)
- 불변
- trim, concat, substring 등 값을 조작하는 메서드는 새로운 인스턴스를 생성

**장점**
- 코드의 표현력을 높여주고 분산되기 쉬운 비즈니스 로직을 한데 묶어준다.
- 불변 - 부작용과 동시성 문제 X, 안전함.
###### Value Object를 사용하는 경우
- 가능한 모든 경우!
- 다른 객체의 속성을 표현하는 도메인의 요소에 사용 (엔티티(사람)의 속성)
- OR 다양한 상태, 비밀번호, 돈 등 **값 자체로 식별**되어 명시적인 식별 필드가 필요 없는 비즈니스 도메인 개념 (color)

#### 2. Entity
- Value Object와 정반대
- 모든 비즈니스 도메인의 필수 구성요소
  **차이점**
1. 다른 Entity 인스턴스와 비교하기 위해 **명시적인 식별 필드 필요** (value object인 name 필드가 같은 경우 식별 필요)
2.  **식별 필드**: 각 Entity의 **인스턴스마다 고유해야 함** / **엔티티의 생애 주기 내내 불변**
    - 식별 필드를 제외한 다른 모든 필드 값이 동일하더라도 인스턴스를 구분할 수 있게 해준다.
3. 엔티티는 불변 X : 변할 것으로 예상
4. Value Object는 Entity의 속성을 설명

#### 3. Aggregate
- 애그리게이트는 엔티티다. (엔티티의 특징을 가지고 있지만, 단순 엔티티가 아닌 그 이상)
    - 1. 명시적인 식별 필드 필요
    - 2. 인스턴스의 생애주기 동안 상태가 변할 것으로 예상
- 애그리게이트는 **일관성을 강화하는 경계다.**
- 애그리게이트의 이름,데이터 멤버, 동작, 도메인 이벤트는 유비쿼터스 언어를 사용해야한다.

**목적**
- 데이터 일관성 보호
    - 애그리게이트의 데이터는 변할 수 있기 때문.
- 애플리케이션 계층(Service 계층)의 조율 동작을 간단하게 한다.

**일관성 강화**
- 모든 들어오는 변경 요청을 검사 (비즈니스 규칙에 위배되지 않게)
- 애그리게이트의 비즈니스 로직을 통해서만 애그리게이트의 상태를 변경할 수 있게 하기
    - 외부 프로세스와 객체는 읽기만 가능.
    - 애그리게이트의 **퍼블릭 인터페이스에 포함된 메서드**만을 통해 상태 변형
        - 위와 같은 상태 변경 메서드를 **커맨드** 라고 한다.

**상태 변경 메소드 (커맨드) 구현**
1. 애그리게이트 객체에 퍼블릭 메서드로 구현
    - public void execute(UserId from, String body)
2. 커맨드에 실행에 필요한 모든 입력값을 포함하는 파라미터 객체로 표현
    - public void execute(AddMessage cmd)

**퍼블릭 인터페이스**
- 입력값 유효성 검사
- 관련된 비즈니스 규칙 및 불변성 강화

**동시성 관리**
- for 애그리게이트 상태의 일관성 유지
- 여러 **프로세스**가 동시에 동일한 애그리게이트 갱신
- 애그리게이트를 저장하는 DB에서 동시성 관리를 지원해야 함.
    - 애그리게이트에서 갱신할 때마다 증가하는 버전 필드 관리
    - DB에 변경사항 커밋 시 처음 읽었던 원본의 버전과 덮어쓰려는 버전이 동일한지 체크 (optimistic lock?)

#### 트랜잭션 경계
-> 애그리게이트의 상태는 자신의 비즈니스 로직을 통해서만 수정될 수 있기에, **트랜잭션 경계**의 역할을 한다.
- 모든 애그리게이트 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리돼야 한다. (모두 커밋 or 롤백)
- 다중 애그리게이트 트랜잭션을 지원하는 시스템 오퍼레이션은 없다고 가정
- 여러 애그리게이트에서 변경을 커밋해야 한다면 잘못된 트랜잭션 경계(즉, 애그리게이트 경계) 임을 나타낸다.
- But 동일한 트랜잭션에서 여러 객체를 수정해야 한다면?

**엔티티 계층**
- 엔티티는 독립적 패턴 X, 애그리게이트의 일부로서 사용

시나리오: 여러 객체가 하나의 트랜잭션 경계를 공유 (동시 변경, 다른 객체의 상태에 의존)
- 엔티티 계층: 엔티티와 밸류 오브젝트를 담고 있다.
- ***이 요소들이 도메인의 비즈니스 로직 경계 내에 있으면 동일한 애그리게이트에 속한다.*
- 애그리게이트: 동일한 트랜잭션 경계에 속한 비즈니스 엔티티와 밸류 오브젝트를 한데 묶는 패턴

**다른 애그리게이트 참조하기**
- 애그리게이트 내의 모든 객체는 같은 트랜잭션 경계를 공유한다.
- 경계 설정 가이드: 데이터의 일관성
- 애그리게이트를 가능한 한 작게 유지하자.

-> 외부 애그리게이트 참조 시 ID를 이용
- 이 같은 객체가 애그리게이트 경계에 속하지 않음을 명시
- 각 애그리게이트가 자신의 트랜잭션 경계를 갖도록 보장

-> 엔티티가 애그리게이트에 속하는지 판단하는 방법
- 비즈니스 로직 내에 데이터의 일관성 , 시스템 상태 손상 야기 여부 판단
- 이러한 데이터는 애그리게이트 경계 안에 속해야 한다.  (데이터 == 엔티티?)
##### 애그리게이트 루트
- 애그리게이트: 엔티티의 계층 구조를 대표
- 이 중 하나만 애그리게이트의 퍼블릭 인터페이스(즉, 애그리게이트 루트)로 지정
    - 이를 통해서만 애그리게이트에 포함된 다른 엔티티들의 상태 수정이 이루어짐

--- 
### 도메인 이벤트
- 애그리게이트 루트의 퍼블릭 인터페이스 외 외부에서 애그리게이트와 커뮤니케이션 하는 메커니즘
- 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지

예시:
- 티켓이 할당됨, 상부에 보고됨, 메시지가 수신됨 (이미 발생한 이벤트: 과거형으로 명명)
-  언제, 무슨 이유로 티켓이 상부에 보고됐는지 설명(하는 데이터)

**목적:**
- 비즈니스 도메인에서 일어난 일 설명 & 이벤트와 관련된 모든 필요한 데이터 제공
- 애그리게이트의 퍼블릭 인터페이스의 일부다.
    - 애그리게이트는 자신의 도메인 이벤트 발행
    - 외부 시스템/다른 프로세스에서 도메인 이벤트 구독, 반응 로직 실행
--- 
##### 도메인 서비스
-> 애그리게이트, 밸류 오브젝트 모두에 속하지 않는 비즈니스 로직을 담는 상태가 없는 객체
- 복수의 애그리게이트에 관련된 비즈니스 로직을 구현하기 위한 것
    - 계산/분석 수행을 위한 다양한 시스템 구성요소의 호출을 조율
    - 여러 애그리게이트의 작업을 쉽게 조율할 수 있다.
    - But, 한 개의 DB 트랜잭션에서 한 개의 애그리게이트 인스턴스만 수정 가능
    - So 여러 애그리게이트의 데이터를 **읽는 것**이 필요한 계산 로직 구현을 도와준다.
---
##### 복잡성 관리
- 애그리게이트 / 밸류 오브젝트 패턴은 비즈니스 로직 구현의 복잡성을 다루는 수단
- 시스템의 복잡성: 제어와 동작 예측의 어려움
    - 이는 시스템의 자유도를 반영한다.
    - 시스템의 자유도: 시스템의 상태를 설명하는 데 필요한 데이터 요소의 개수
    - 애그리게이트/밸류 오브젝트 패턴의 불변성은 복잡성을 낮춘다.
        - 밸류 오브젝트의 상태와 관련된 모든 비즈니스 로직은 자신의 경계 안에 존재
        - 애그리게이트는 자신의 메서드를 통해서만 수정 : 비즈니스 불변성 보호, 자유도 하락

---

도메인 모델 패턴
- 복잡한 비즈니스 로직을 다루기 위함
- 핵심 하위 도메인 적용