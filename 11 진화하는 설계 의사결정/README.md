# 11 진화하는 설계 의사결정

기업은 경쟁에서 뒤처지지 않으려면, 정신 바짝 차려야 합니다.
계속 변화 및 진화하고 시간이 흐름에 따라 스스로를 재창조해야 합니다.

소프트웨어 설계도 마찬가지입니다.
변경사항을 제대로 관리해야 유지보수 및 개선을 용이하게 할 수 있습니다.

크게 4가지 관점에서 환경 변화가 소프트웨어 설계 의사결정에 미치는 영향을 파악합니다.

- 비즈니스 도메인
- 조직 구조
- 도메인 지식
- 성장

## 도메인 변경

하위 도메인의 유형은 변화할 수 있습니다.

### 핵심〃 -> 일반〃

- A사의 자체 주문 배송 솔루션을 구현해 이용하는데, 혁신적인 배송 경로 최적화 알고리즘이 포함되어 있습니다. 이를 통해 경쟁사 대비 낮은 배송료를 제공하여 경쟁 우위를 갖습니다.
- 그런데 B사에서 외판원 문제를 해결한 아주 혁신적인 경로 최적화 서비스를 상용 솔루션으로 제공하기 시작하였습니다. 이를 이용한다면 더 저렴하고 더 최적화된 작업이 가능합니다.
- 이렇게 되면 A사의 자체 솔루션이 핵심〃에서 일반〃으로 바뀝니다. 모든 경쟁사가 최적의 솔루션을 사용할 수 있게 되어, 경쟁 우위를 잃었기 때문입니다. (혹은 R&D에 막대한 투자를 해 경쟁 우위를 확보할 수도 있습니다.)

### 일반〃 -> 핵심〃

- 상용 재고 관리 솔루션이 A사의 제품 복잡성에 적합하지 않아 잘못된 재고 예측을 보입니다. A사는 BI 보고서를 통해 이를 파악하고 자체 시스템 설계 및 구축에 투자하기로 전략적 의사결정을 내립니다.
- 기능이 성공적으로 구축된다면 일반 솔루션에 머무는 경쟁사 대비 경쟁 우위를 확보할 수 있습니다. 따라서 재고 관리가 일반〃에서 핵심〃으로 바뀝니다.
- 사례: Amazon은 (서버) 인프라 관리 시스템을 **재창조**(도메인 전환 발생)하고, 나중에 이를 AWS라는 비즈니스로 전환했습니다.

### 지원〃 -> 일반〃

- A사 마케팅 부서의 계약 관리 시스템은 특별한 게 없는 CRUD뿐인 지원〃이었습니다.
- 계약 관리 솔루션이 오픈소스로 나왔는데, 여기에 기존 기능이 모두 있습니다. 추가로 백로그에 있지만 비즈니스 영향이 적던 고급 기능들도 포함되어 있습니다. A사는 사내 솔루션을 버리고 오픈소스를 연동합니다. 지원〃에서 일반〃으로 바뀝니다.

### 지원〃 -> 핵심〃

- 지원 로직이 비용 절감 또는 추가 수익 창출을 목적으로 최적화된다면, 핵심〃으로 전환된다고 볼 수 있습니다.
- 지원〃의 시간에 따른 복잡성 증가로 판단할 수 있습니다.
  - 복잡성 증가가 회사의 이익에 영향이 없다면 -> 우발적 비즈니스 복잡성
  - 영향이 있다면 -> 지원〃에서 핵심〃으로 전환될 징조

### 핵심〃 -> 지원〃

- 복잡성이 **정당화**되지 않은 경우, 즉 복잡성에 비해 수익성이 없는 경우 전환될 수 있습니다. 이때 다른 하위 도메인을 위한 최소한의 로직만 남기고 복잡성을 줄이기로 결정할 수 있습니다.

### 일반〃 -> 지원〃

- 아까 지원〃 -> 일반〃 사례에서, 오픈 소스 솔루션이 별로라고 생각한다면(통합 과정의 복잡성 대비 얻는 이점을 정당화할 수 없다면) 다시 롤백할 수 있습니다.

![diagram](https://lunaticsy.github.io/posts/development-books/learning-domain-driven-design/pic-11-1.png)

## 전략적 설계 문제

하위 도메인 유형 변경은 바운디드 컨텍스트, 결과적으론 전략적 설계 의사결정에도 영향을 줍니다.

- 핵심〃은 충돌 방지 계층으로 모델을 보호해야 합니다.
- 핵심〃은 오픈 호스트 서비스로 모델의 변경으로부터 사용자를 보호해야 합니다.
- 분리형 노선을 쓰던 일반〃 또는 지원〃이 핵심〃으로 전환된다면, 더 이상 코드의 중복은 허용되지 않습니다. 각 팀은 핵심〃과 연동해야만 합니다. 대체로 핵심〃은 한 팀에서만 구현되므로, 사용자-제공자 관계가 적합합니다.
- 지원〃이 핵심〃으로 전환된다면 사내에서 개발되어야 합니다.
- 핵심〃이 지원〃으로 전환된다면 외주를 맡길 수 잇습니다.

## 전술적 설계 문제

- 기존 설계가 복잡한 기능을 지원하지 않아 기능 추가가 고통스럽다면, 이는 비즈니스 도메인과 설계 의사결정을 재평가할 중요한 신호입니다.
- 변화는 두려운 것이 아니라 자연스러운 일이며, 비즈니스의 발전은 예측할 수 없습니다.
- 가장 정교한 디자인 패턴을 적용하는 것은 비효율적이며, 현 상황에서 가장 적합한 것을 선택한 후 필요하면 개선하는 것이 더 유리합니다.
- 비즈니스 로직의 모델링 방법, 가능한 설계 옵션 및 이들 사이의 차이점을 알고 있다면, 디자인 패턴 마이그레이션은 어렵지 않습니다.

### 트랜잭션 스크립트 -> 액티브 레코드

- 둘 다 절차지향 스크립트를 이용하지만, 액티브 레코드는 DB 매핑 복잡성을 자료구조를 사용해 캡슐화합니다.
- 트랜잭션 스크립트에서 데이터 작업이 어려워지면, 액티브 레코드로 리팩토링합시다. 복잡한 자료구조를 액티브 레코드로 캡슐화하고, DB에 직접 접근하는 대신 액티브 레코드를 이용해 모델 및 구조를 추상화합니다.

### 액티브 레코드 -> 도메인 모델

- 비즈니스 로직이 복잡해지고 불일치 및 중복 사례가 많아진다면 도메인 모델 패턴으로 리팩토링합니다.

첫째: 밸류 오브젝트로 리팩토링하기

- 불변 객체로 둘 수 있는 데이터 및 관련 비즈니스 로직을 찾아 밸류 오브젝트로 만듭니다.

둘째: 트랜잭션의 경계 찾기

- 팁: 상태 mutation을 액티브 레코드 내부로 메소드화하려면, 모든 액티브 레코드의 property setter들을 private으로 바꿔봅니다. 이제 컴파일 에러가 뜨는 부분들을 찾아서, 액티브 레코드 경계 내부로 옮깁니다.

### 도메인 모델 -> 이벤트 소싱 도메인 모델

- 애그리게이트 경계가 적절하게 설계된 도메인 모델은 이벤트 소싱 모델로 전환할 수 있습니다.
- 어려운 점은, 로그가 없는 현재 상태에서 이벤트 기반 모델을 만들어내야 하는 점입니다.

선택지 1: 전환에 필요한 과거 이력 생성

- 데이터를 보면서 그 상태를 만들 수 있는 이벤트를 상상해 만들어봅니다.
- 단점: 놓친 히스토리들 전체를 복구하는 것은 불가능합니다. 이미 묻혀버려서 현재 상태에는 드러나지 않는 이력들도 있기 때문입니다.

선택지 2: 마이그레이션 이벤트 모델링

- 과거 이벤트에 대한 지식이 너무 부족하다면, 오히려 이를 명시하는 방법입니다.
- `migrated-from-legacy`와 같은 이벤트 타입을 만들어서, 과거 히스토리는 모두 날리고 현재 상태만을 나타내는 이벤트를 발행합니다.
- 선택지 1에 비해, 히스토리 중간 누락과 같은 무결성 훼손 문제는 발생하지 않습니다.
- 단점: 레거시 시스템의 흔적이 이벤트 스토어에 영원히 남습니다. 이는 나중에 CQRS를 사용하는 경우 등에서 마이그레이션 이벤트도 고려해야 하는 복잡성을 야기합니다.
