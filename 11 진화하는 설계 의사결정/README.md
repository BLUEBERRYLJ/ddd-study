# 11 진화하는 설계 의사결정

기업은 경쟁에서 뒤처지지 않으려면, 정신 바짝 차려야 합니다.
계속 변화 및 진화하고 시간이 흐름에 따라 스스로를 재창조해야 합니다.

소프트웨어 설계도 마찬가지입니다.
변경사항을 제대로 관리해야 유지보수 및 개선을 용이하게 할 수 있습니다.

크게 4가지 관점에서 환경 변화가 소프트웨어 설계 의사결정에 미치는 영향을 파악합니다.

- 비즈니스 도메인
- 조직 구조
- 도메인 지식
- 성장

## 도메인 변경

하위 도메인의 유형은 변화할 수 있습니다.

### 핵심〃 -> 일반〃

- A사의 자체 주문 배송 솔루션을 구현해 이용하는데, 혁신적인 배송 경로 최적화 알고리즘이 포함되어 있습니다. 이를 통해 경쟁사 대비 낮은 배송료를 제공하여 경쟁 우위를 갖습니다.
- 그런데 B사에서 외판원 문제를 해결한 아주 혁신적인 경로 최적화 서비스를 상용 솔루션으로 제공하기 시작하였습니다. 이를 이용한다면 더 저렴하고 더 최적화된 작업이 가능합니다.
- 이렇게 되면 A사의 자체 솔루션이 핵심〃에서 일반〃으로 바뀝니다. 모든 경쟁사가 최적의 솔루션을 사용할 수 있게 되어, 경쟁 우위를 잃었기 때문입니다. (혹은 R&D에 막대한 투자를 해 경쟁 우위를 확보할 수도 있습니다.)

### 일반〃 -> 핵심〃

- 상용 재고 관리 솔루션이 A사의 제품 복잡성에 적합하지 않아 잘못된 재고 예측을 보입니다. A사는 BI 보고서를 통해 이를 파악하고 자체 시스템 설계 및 구축에 투자하기로 전략적 의사결정을 내립니다.
- 기능이 성공적으로 구축된다면 일반 솔루션에 머무는 경쟁사 대비 경쟁 우위를 확보할 수 있습니다. 따라서 재고 관리가 일반〃에서 핵심〃으로 바뀝니다.
- 사례: Amazon은 (서버) 인프라 관리 시스템을 **재창조**(도메인 전환 발생)하고, 나중에 이를 AWS라는 비즈니스로 전환했습니다.

### 지원〃 -> 일반〃

- A사 마케팅 부서의 계약 관리 시스템은 특별한 게 없는 CRUD뿐인 지원〃이었습니다.
- 계약 관리 솔루션이 오픈소스로 나왔는데, 여기에 기존 기능이 모두 있습니다. 추가로 백로그에 있지만 비즈니스 영향이 적던 고급 기능들도 포함되어 있습니다. A사는 사내 솔루션을 버리고 오픈소스를 연동합니다. 지원〃에서 일반〃으로 바뀝니다.

### 지원〃 -> 핵심〃

- 지원 로직이 비용 절감 또는 추가 수익 창출을 목적으로 최적화된다면, 핵심〃으로 전환된다고 볼 수 있습니다.
- 지원〃의 시간에 따른 복잡성 증가로 판단할 수 있습니다.
  - 복잡성 증가가 회사의 이익에 영향이 없다면 -> 우발적 비즈니스 복잡성
  - 영향이 있다면 -> 지원〃에서 핵심〃으로 전환될 징조

### 핵심〃 -> 지원〃

- 복잡성이 **정당화**되지 않은 경우, 즉 복잡성에 비해 수익성이 없는 경우 전환될 수 있습니다. 이때 다른 하위 도메인을 위한 최소한의 로직만 남기고 복잡성을 줄이기로 결정할 수 있습니다.

### 일반〃 -> 지원〃

- 아까 지원〃 -> 일반〃 사례에서, 오픈 소스 솔루션이 별로라고 생각한다면(통합 과정의 복잡성 대비 얻는 이점을 정당화할 수 없다면) 다시 롤백할 수 있습니다.

![diagram](https://lunaticsy.github.io/posts/development-books/learning-domain-driven-design/pic-11-1.png)

## 전략적 설계 문제

하위 도메인 유형 변경은 바운디드 컨텍스트, 결과적으론 전략적 설계 의사결정에도 영향을 줍니다.

- 핵심〃은 충돌 방지 계층으로 모델을 보호해야 합니다.
- 핵심〃은 오픈 호스트 서비스로 모델의 변경으로부터 사용자를 보호해야 합니다.
- 분리형 노선을 쓰던 일반〃 또는 지원〃이 핵심〃으로 전환된다면, 더 이상 코드의 중복은 허용되지 않습니다. 각 팀은 핵심〃과 연동해야만 합니다. 대체로 핵심〃은 한 팀에서만 구현되므로, 사용자-제공자 관계가 적합합니다.
- 지원〃이 핵심〃으로 전환된다면 사내에서 개발되어야 합니다.
- 핵심〃이 지원〃으로 전환된다면 외주를 맡길 수 잇습니다.

## 전술적 설계 문제

- 기존 설계가 복잡한 기능을 지원하지 않아 기능 추가가 고통스럽다면, 이는 비즈니스 도메인과 설계 의사결정을 재평가할 중요한 신호입니다.
- 변화는 두려운 것이 아니라 자연스러운 일이며, 비즈니스의 발전은 예측할 수 없습니다.
- 가장 정교한 디자인 패턴을 적용하는 것은 비효율적이며, 현 상황에서 가장 적합한 것을 선택한 후 필요하면 개선하는 것이 더 유리합니다.
- 비즈니스 로직의 모델링 방법, 가능한 설계 옵션 및 이들 사이의 차이점을 알고 있다면, 디자인 패턴 마이그레이션은 어렵지 않습니다.

### 트랜잭션 스크립트 -> 액티브 레코드

- 둘 다 절차지향 스크립트를 이용하지만, 액티브 레코드는 DB 매핑 복잡성을 자료구조를 사용해 캡슐화합니다.
- 트랜잭션 스크립트에서 데이터 작업이 어려워지면, 액티브 레코드로 리팩토링합시다. 복잡한 자료구조를 액티브 레코드로 캡슐화하고, DB에 직접 접근하는 대신 액티브 레코드를 이용해 모델 및 구조를 추상화합니다.

### 액티브 레코드 -> 도메인 모델

- 비즈니스 로직이 복잡해지고 불일치 및 중복 사례가 많아진다면 도메인 모델 패턴으로 리팩토링합니다.

첫째: 밸류 오브젝트로 리팩토링하기

- 불변 객체로 둘 수 있는 데이터 및 관련 비즈니스 로직을 찾아 밸류 오브젝트로 만듭니다.

둘째: 트랜잭션의 경계 찾기

- 팁: 상태 mutation을 액티브 레코드 내부로 메소드화하려면, 모든 액티브 레코드의 property setter들을 private으로 바꿔봅니다. 이제 컴파일 에러가 뜨는 부분들을 찾아서, 액티브 레코드 경계 내부로 옮깁니다.

### 도메인 모델 -> 이벤트 소싱 도메인 모델

- 애그리게이트 경계가 적절하게 설계된 도메인 모델은 이벤트 소싱 모델로 전환할 수 있습니다.
- 어려운 점은, 로그가 없는 현재 상태에서 이벤트 기반 모델을 만들어내야 하는 점입니다.

선택지 1: 전환에 필요한 과거 이력 생성

- 데이터를 보면서 그 상태를 만들 수 있는 이벤트를 상상해 만들어봅니다.
- 단점: 놓친 히스토리들 전체를 복구하는 것은 불가능합니다. 이미 묻혀버려서 현재 상태에는 드러나지 않는 이력들도 있기 때문입니다.

선택지 2: 마이그레이션 이벤트 모델링

- 과거 이벤트에 대한 지식이 너무 부족하다면, 오히려 이를 명시하는 방법입니다.
- `migrated-from-legacy`와 같은 이벤트 타입을 만들어서, 과거 히스토리는 모두 날리고 현재 상태만을 나타내는 이벤트를 발행합니다.
- 선택지 1에 비해, 히스토리 중간 누락과 같은 무결성 훼손 문제는 발생하지 않습니다.
- 단점: 레거시 시스템의 흔적이 이벤트 스토어에 영원히 남습니다. 이는 나중에 CQRS를 사용하는 경우 등에서 마이그레이션 이벤트도 고려해야 하는 복잡성을 야기합니다.

## 조직 변화

조직 구조의 변화는 의사소통 및 협업에 영향을 주고, 이는 바운디드 컨텍스트 통합 방식에 영향을 줍니다.

- 바운디드 컨텍스트는 한 팀에서만 구현할 수 있습니다. 개발 센터가 성장해서 개발팀이 둘이 되었다면, 바운디드 컨텍스트 경계가 더 작게 분할됩니다. 각 팀은 각자의 바운디드 컨텍스트에서 작업합니다.
- 개발 센터가 더 성장해서 사무실이 늘어날 수도 있습니다. 이는 협업에 부정적인 영향을 줍니다.

### 파트너십 -> 사용자-제공자

- 파트너십 패턴은 팀 간의 강력한 의사소통과 협업이 필요하지만, 이 전제는 시간이 흐름에 따라 없어질 수 있습니다.
- 일부 조직이 지역적으로 멀리 떨어진 사무실로 이전한다면, 의사소통에 부정적인 영향이 생기므로 이러한 전환이 적절할 수 있습니다.

### 사용자-제공자 -> 분리형 노선

- 지리적 거리나 정치적 이슈로 의사소통 문제가 심각해질 수 있습니다. 그렇다면 시간이 지날 수록 통합 문제는 점점 더 많아집니다.
- 어떤 특이점 이후로는 그냥 기능을 복제하는 것이 더 비용 효과적일 수 있습니다.

## 도메인 지식

DDD의 핵심 신조: 도메인 지식은 소프트웨어 설계에 필수적입니다.

- 도메인 지식 습득은 핵심〃에서 가장 어려운 일입니다. 로직도 복잡하고, 자주 변경될 것이기 때문입니다.
- 모델링은 지속적인 일입니다. 비즈니스 도메인 지식을 얻을 때마다 모델을 개선해야 합니다.

복잡성

- 잘 드러나지 않습니다. 초기에는 간단하고 쉬워보입니다.
- 순식간에 복잡해집니다. 기능 추가에 따라 엣지 케이스, 불변성, 규칙이 발견됩니다.
- 때로는 바운디드 컨텍스트, 애그리게이트, 경계 등 모델을 다시 만들어야 할 수도 있습니다.

휴리스틱: 바운디드 컨텍스트 설계를 지식 수준에 따라서 하기

- 지식 수준이 부족하면 일단 크게 설계합니다. 나중에 쪼개는 비용이 잘못 쪼갠 것으로 인한 유지보수 비용보다 저렴합니다.
- 특히 불명확하고 자주 변경될 수록 크게 잡습니다.
- 시간이 지나 지식의 발견과 로직의 변경사항이 안정화되면, 더 좁은 바운디드 컨텍스트 또는 **마이크로서비스**로 분해할 수 있습니다. (14장)

도메인 지식의 변화에 인한 레거시

- 도메인 지식은 늘어날 수도 있지만 손실될 수 있습니다.
  - 부실해지는 문서들
  - 회사를 떠나는 설계 참여자들
  - 임시변통으로 추가되는 새로운 기능들
- 이는 결국 코드베이스가 의심스러운 상태의 레거시 시스템이 됩니다.
- 이러한 지식을 복구하는 것은 다음 장의 EventStorming에서 배웁니다.

## 성장

커다란 진흙 덩어리

- 성장과 기능 추가는 프로젝트가 성공적이라는 신호입니다.
- 하지만 코드베이스는 커다란 진흙 덩어리로 성장할 수도 있습니다.

### 하위 도메인

- 비즈니스 도메인 성장에 따라 하위 도메인은 경계가 흐려질 수 있습니다.
- 여러 개로 세분화된 하위 도메인에 걸쳐있는 하위 도메인은 더 식별하기 어렵습니다. 따라서 응집된 유즈케이스에서 휴리스틱을 통해 하위 도메인을 다시 나누는 것도 중요합니다.
- 하위 도메인과 유형에 대한 정보가 정확할 수록 유리합니다.

### 바운디드 컨텍스트

- 3장에서 바운디드 컨텍스트를 통해, 비즈니스 도메인의 다양한 모델을 각각의 초점에 맞게 다룰 수 있다고 배웠습니다.
- 바운디드 컨텍스트가 초점을 잃는 것은 흔하며, 우발적 복잡성입니다. 그렇다면 경계를 다시 살펴봅시다.
- 특정 문제를 위한 바운디드 컨텍스트를 추출해서 모델을 단순화합시다.
- 성장에 따라 기존에 드러나지 않던 설계 문제가 드러날 수 있습니다. 예컨대 바운디드 컨텍스트가 다른 바운디드 컨텍스트 없이는 작업을 완료하지 못하는 경우입니다. 이는 모델이 비효율적이라는 신호로, 경계를 재설계해 각 바운디드 컨텍스트의 자율성을 높여야 합니다.

### 애그리게이트

- 6장에 따르면 애그리게이트를 가능한 작게 유지하고, 강력하게 일관적인 상태를 유지해야 하는 객체만 포함해야 합니다.
- 때로는 이미 있는 애그리게이트에 새 기능을 붙이는게 편할 수도 있습니다. 다만 강력한 일관성을 유지할 필요가 없는 데이터로 인해 애그리게이트가 커진다면, 이는 제거해야 하는 우발적 복잡성입니다.
- 비즈니스 기능을 전담 애그리게이트로 추출하면 애그리게이트도, 속한 바운디드 컨텍스트도 단순해집니다. 때로는 새 바운디드 컨텍스트로 추출해야 할 숨겨진 모델이 발견될 때도 있습니다.
