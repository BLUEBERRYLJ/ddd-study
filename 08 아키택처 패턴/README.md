# 08 아키택처 패턴

## 계층형 아키텍처

- 프레젠테이션 계증, 비즈니스 로직 계층, 데이터 접근 계층 으로 구성됨

### 프레젠테이션 계층 (사용자 인터페이스 계층)

- 외부 환경으로부터 response를 받고 request를 주는 레이어
- 프로그램의 퍼블릭 인터페이스
- 웹 UI, CLI, GUI, RestAPI, 이벤트에 대한 구독, 이벤트를 발생하는 메시지 토픽
    - 메시지 listener는 프레젠테이션 계층이였다

### 비즈니스 로직 계층 (도메인 계층, 모델 계층)

- 액티브 레코드, 도메인 모델과 같은 로직 패턴을 수행
- 해당 소프트웨어의 중심이되는 의사결정을 하는 레이어

### 데이터 접근 계층 (인프라스트럭쳐 계층)

- 말 그대로 데이터 베이스에 직접적으로 접근하는 계층

### 계층 간 커뮤니케이션

- 각 계층은 자신의 아래 계층에만 의존
- 프레젠테이션 - 비즈니스 (o)
- 비즈니스-데이터 (o)
- 프레젠테이션-데이터 (x)

### 서비스 계층 (애플리케이션 계층)

- 프레젠테이션 계층과 비즈니스 로직 계층 사이의 중간 계층
- 비즈니스 계층과 소통하는데 필요한 데이터를 감싸서 프레젠테이션 계층과 주고받음
- 이를 통해 아래와 같은 장점을 가짐
    - 동일한 서비스 계층을 여러 퍼블릭 인터페이스에서 재사용할 수 있다 (특히 api)
    - 모든 관련 메서드를 한 곳에 모으면 모듈화가 개선됨
    - 프레젠테이션 계층과 비즈니스 로직 계층의 결합도를 낮춤
    - 비즈니스 기능을 테스트하기 쉬워짐
- 비즈니스 로직 패턴에서 외부 조율을 해야하는 상황이 아니라면 반드시 필요한 계층은 아님
    - 필요아 따라서 생략 가능

### 계층형 아키텍처를 사용하는 경우

- 비즈니스 로직이 트랜잭션 스크립트 또는 액티브 레토드 패턴을 사용할 때
- 도메인 모델을 구현하는데 계층형 아키텍처 패턴은 적용이 힘듦

---

## 포트와 어댑터

- 계층형 아키텍처의 단점을 해결하고 좀 더 복잡한 비즈니스 로직을 구현하기에 적합
- **이 아키텍처에서는 인프라스트럭처 계층에 프레젠테이션 계층이 통합되어 있음**

### 의존성 역전의 원리

- 
- 비즈니스 로직을 구현하는 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안됨
- 따라서 계층형 구조와 달리, 인프라스트럭처 계층이 비즈니스 로직 계층에 의존함
- 아래와 같은 계층 구조를 가짐
- 인프라스트럭쳐 계층 -> 애플리케이션 계층 -> 비즈니스 계층

### 인프라 구성요소의 연동

- 비즈니스 로직 계층: 인프라스트럭처 계층이 구현할 포트를 정의
- 인프라스트럭처 계증: 포트를 호출하는 어댑터를 정의

### 포트

- Driving Port
    - 외부에서 핵심 비즈니스 로직을 호출하기 위한 입구
    - RestAPI 요청, GUI 버튼 클릭 등
- Driven Port
    - 핵심 로직이 어플리케이션 외부와 소통하기 위한 인터페이스
    - 데이터베이스 호출, 외부 api 호출 등

### 어댑터

- Driving Adapter: 외부 요청을 받아서 Driving Port를 호출하는 것
- Driven Adapter: Driven Port를 통해 외부와 소통하는 방법을 구현

### 동작 순서

1. 사용자가 버튼을 클릭함
2. Driving Adapter (웹서버 등)이 알맞은 Driving Port를 호출
3. Driving Port에서 적절한 비즈니스 로직 수행
4. 로직 중 필요할 경우, Driven Port에 해당 기능 요청
5. Driven Port에서 Driven Adapter로 요청 전달
6. Driven Adapter에서 외부와 통신 후 반환
7. 핵심 비즈니스 로직 결과를 Driving Adapter를 통해 반환
8. 

---

## CQRS (commend-query-responsibility segregation)

### 폴리글랏 모델링

- 데이터베이스에는 제각기 교유한 단점과 장점이 있음
- 다양한 데이터베이스를 사용하면서 각 데이터베이스의 단점을 보완하고 장점만 취함

### 구현

- 이름 그대로 커맨드와 쿼리에 대한 책임을 분리 시킨다
- 이를 구현하기 위해 아래 두가지 유형을 사용한다.

### 커맨드 실행 모델

- 시스템의 상태를 수정하는 커맨드를 전담으로 수행함
- 비즈니스 엔티티의 일관적 상태를 읽을 수 있어야 하고 갱신할 때 낙관적 동시성을 지원
- 쓰기 전용으로 어떤 데이터도 반환해서는 안됨(???)
    - 단지 실행이 성공 또는 실패 여부만 반환

### 읽기 모델

- 사용자 또는 다른 시스템에 데이터를 필요한 만큼 보여줌
- 캐시에서 언제든 다시 생성할 수 있음
- 읽기 전용으로, 이 모델을 통해서는 수정이 불가능함

### 프로젝션을 생성하는 방식

### 동기식 프로젝션

- 격차 해소 구독 모델을 통해 변경사항을 가져옴
    1. 프로젝션 엔진이 OLTP 데이터베이스에서 마지막 체크포인트 이후의 변경사항을 조회
    2. 프로젝션 엔진이 해당 변경사항을 읽기 모델에 반영
    3. 프로젝션 엔진이 마지막으로 처리한 레코드를 체크포인트에 저장
- liquibase 감성
- 처음부터 다시 생성하려면 그냥 체크포인트를 0 으로 초기화 시키면 됨

### 비동기식 프로젝션

- 모든 커밋된 변경사항을 메시지 버스에 발행
- 프로젝션 엔진이 메시지를 구독 -> 메시지를 소비하면서 읽기 모델을 갱신
- 단점
    - 분산 컴퓨팅에서 메시지의 순서가 잘못되거나 중복처리되면 데이터의 일관성이 없어짐
    - 새로운 프로젝션 추가 및 재 생성이 어려움

### CQRS, 언제 써야하는 것인가

- 다양한 종류의 데이터베이스를 사용할 때
- 이벤트 소싱 도메인 모델
    - 이벤트 소싱 모델에서는 레코드 조회가 불가능하지만 CQRS에서는 가능

---

## 적용 범위

- 전체 바운디드 컨텍스트에 단일 아키텍처를 적용하면 안됨
- 실제 필요성과 비즈니스 전략에 따른 아키텍처 선택이 필요