아래와 같은 기능을 하는 시스템 요소 전반의 커뮤니케이션 흐름 구성 패턴에 대해 알아보자. 
- 용이한 바운디드 컨텍스트 간 커뮤니케이션
- 애그리게이트 설계 원칙에 의해 부과된 제한 사항 해결
- 여러 시스템 컴포넌트에 걸쳐 비즈니스 프로세스 조율

#### 모델 변환
Revision
- 바운디드 컨텍스트: 유비쿼터스 언어 모델의 경게
- 3장: 서로 다른 바운디드 컨텍스트에서의 커뮤니케이션 방법
	- 1.  파트너십, 2. 공유 커널, 3. 업스트림-다운스트림 패턴

##### 업스트림-다운스트림 패턴
- 다운스트림 바운디드 컨텍스트가 업스트림 바운디드 컨텍스트 모델을 따를 수 없는 경우
- 바운디드 컨텍스트의 모델을 변환하여 커뮤니케이션을 용이하게 하는 정교한 기술 솔루션 필요
- 다운스트림의 충돌 방지 계층(ACL) / 업스트림의 오픈 호스트 서비스 (OHS)
- 모델 변환 로직은 stateless 또는 stateful이 될 수 있다. 
	- Stateless: 수신 (OHS) 또는 발신(ACL)이 발행할 때 즉석에서 발생
	- Stateful: 상태 보존을 위해 DB를 사용하여 더 복잡한 변환 로직을 다룸

---
##### Stateless 모델 변환
- 모델 변환을 소유하는 바운디드 컨텍스트에서 **프락시 디자인 패턴**을 통해 구현 (업스트림: OHS, 다운스트림: ACL)
- **수신과 발신 요청 삽입, 소스 모델을 바운디드 컨텍스트의 목표 모델에 매핑**

`요청 --(모델 A)--> 프락시 --(모델 B)--> 목표`

- 바운디드 컨텍스트의 통신 방식에 따라 구현이 달라진다.

###### 동기
- 동기적 통신에 사용하는 모델을 변환하는 방법
- 바운디드 컨텍스트의 코드베이스에 변환 로직을 포함
	- OHS: 공용 언어로의 변환은 유입되는 요청을 처리할 때 발생
	- ACL: 업스트림 바운디드 컨텍스트를 호출할 때 발생

- 경우에 따라 변환 로직을 API gateway pattern과 같은 외부 컴포넌트로 넘기는것이 더 효과적
	- 내부 모델을 통합에 최적화된 공표된 언어로 변환하는 역할
	- 명시적 API gateway로 바운디드 컨텍스트 API의 여러 버전을 관리 가능 (공표된 언어의 다른 버전 노출)
	- 여러 다운스트림 바운디드 컨텍스트에서 사용 가능: ACL은 통합 관련 바운디드 컨텍스트의 역할을 한다. 
	- 이러한 바운디드 컨텍스트는 다른 컴포넌트에서 좀 더 편리하게 사용할 수 있게 모델을 변환하는 역할을 하며, 종종 **교환 컨텍스트**라고도 불린다. 

###### 비동기
- 비동기 통신에 사용하는 모델을 변환하기 위해 **메시지 프락시(Message Proxy)** 구현
- **Message Proxy**: 소스 바운디드 컨텍스트에서 오는 메시지를 구독하는 중개 컴포넌트
	- 필요한 모델 변환을 적용
	- 결과 메시지를 대상 구독자에게 전달
- 오픈 호스트 서비스 구현에 필수
	- 도메인 이벤트가 그대로 발행되어 바운디드 컨텍스트의 구현 모델을 노출하는걸 방지
	- 도메인 이벤트를 가로채 공표된 언어로 변환
	- 바운디드 컨텍스트의 상세를 더 잘 캡슐화 

---
##### Stateful 모델 변환
- 용도:
	- 원천 데이터 집계, 여러 개 요청에서 들어오는 데이터를 단일 모델로 통합해야 하는 변환 메커니즘

###### 들어오는 데이터 집계하기
- 유입되는 데이터를 추적하고 처리하기 위한 변환 로직에는 영구 저장소 필요 (why?)
- 스트림 처리 플랫폼 (Kafka, AWS Kinesis) or 일괄 처리 솔루션 (Apache NiFi, AWS Glue, Spark) 사용 가능

###### 여러 요청 통합 
- 다른 바운디드 컨텍스트를 포함해 여러 요청에서 집계된 데이터 처리 
- 예시:
	- 여러 서비스에서 발생하는 데이터 결합 (backend-for-frontend pattern)
	- 여러 다른 컨텍스트의 데이터를 처리하고 이를 위해 복잡한 비즈니스 로직을 구현하는 바운디드 컨텍스트
			- 다른 모든 바운디드 컨텍스트에서 데이터를 집계하는 ACL을 바운디드 컨텍스트 전면에 배치
			- 바운디드 컨텍스트 연동과 비즈니스 로직의 복잡성 분리 가능

--- 
### 애그리게이트 연동
- 6장: 애그리게이트가 시스템의 나머지 부분과 통신하는 방법 -  도메인 이벤트 발행 
- 도메인 이벤트가 메시지 버스에 발행되는 방법

1. 애그리게이트에서 도메인 이벤트 발행 - 2가지 문제점
	- 애그리게이트의 새 상태가 DB에 커밋되기 전 이벤트 전달
	- 후속 애그리게이트 로직으로 인해 작업 무효화 또는 DB 트랜잭션 미 커밋시 롤백되더라도 이벤트는 이미 발행되는 문제 
```C#
public class Campaign {
	var newEvent = new CampaignDeactivated(_id, reason); //새 이벤트 인스턴스화 
	_events.Append(newEvent); ;//도메인 이밴트 내부 목록에 새 이벤트 추가
	_messageBus.Publish(newEvent); //메시지 버스로 발행
}
```

2. 애플리케이션 계층에서 도메인 이벤트 발행
```C#
public class ManagementAPI {
	var campaign = repository.Load(id); //애그리게이트 인스턴스 로드 및 비활성화 후 커밋
	campaign.Deactivate(reason);
	_repository.CommigChanges(campaign);

	var events = campaign.GetUnpublishedEvents(); //갱신된 상태가 DB에 커밋된 후 도메인 이벤트를 메시지 버스에 발행
	for (IDomainEvent e in events) {
	_messageBus.publish(e);
	}
	campaign.ClearUnpublishedEvents();
}
```
- 괜찮아 보이지만 로직을 실행하는 프로세스가 도메인 이벤트를 발행하지 못할 경우 잔존:
	- 메시지 버스 다운, 또는
	- DB 트랜잭션 커밋 직후 이벤트 발행 전 서버 코드 실행 실패,
	- 트랜잭션은 커밋되지만 도메인 이벤트는 발행 X
- 이러한 케이스를 해결하는 방법 -> 아웃박스 패턴 사용

#### 아웃박스 패턴
- 애그리게이트의 도메인 이벤트를 발행하는 안정적인 방법
- 다른 프로세스가 실패에 직면해도 도메인 이벤트를 항상 발행한다. 

방법
- 업데이트된 애그리게이트의 상태와 새 도메인 이벤트를 모두 동일한 원자성 트랜잭션으로 커밋
- 메시지 릴레이는 DB에서 새로 커밋된 도메인 이벤트를 가져옴
- 릴레이는 도메인 이벤트를 메시지 버스에 발행
- 성공적으로 발행되면 릴레이는 이벤트를 DB에 발행한 것으로 표시하거나 완전히 삭제
![[IMG_5167.heic]]

애플리케이션 --(커밋: 상태+도메인 이벤트)--> 실시간 데이터처리 DB --(발행되지 않은 이벥트)--> 메시지 릴레이 --(발행)--> 메시지 버스

관계형 데이터베이스 사용 시 
- 두개의 테이블에 원자적으로 커밋 후 메시지를 저장하기 위한 전용 테이블 사용하는 기능 활용
NoSQL 사용 시
- 다중 문서 트랜잭션 지원 X, 도메인 이벤트를 애그리게이트 레코드에 포함

###### 발행되지 않은 이벤트 가져오기
- (메시지) 발행 릴레이는 풀/푸시 기반 방식으로 새 도메인 이벤트를 가져온다. 

풀: 발행자 폴링
- 릴레이는 발행되지 않은 이벤트에 대해 DB를 지속해서 질의 
푸시: 트랜잭션 로그 추적
- DB 기능으로 새 이벤트가 추가될 때 마다 발행 릴레이를 호출(질의)

---
#### 교차 컴포넌트 비즈니스 프로세스 구현하기

#### 사가
정의
- 오래 지속되는, 여러 애그리게이트(트랜잭션)에 걸쳐 있는 비즈니스 프로세스를 말한다.


목적
- 관련 컴포넌트에서 발생하는 이벤트를 수신하고, 다른 컴포넌트에 후속 커맨드를 실행한다. 
- 실행 단계 중 실패 시 시스템 상태를 일관되게 유지하도록 적절한 보상 조치를 내리는 것을 담당
- 예시) 광고 캠페인과 퍼블리셔 엔티티
	- 퍼블리셔가 확인을 받으면 캠페인 발행 상태 발행됨으로 변경, 거부한 경우 거부됨으로 변경
	- 하지만 둘은 다른 책임 및 다른 바운디드 컨텍스트에 속하는 비즈니스 엔티티

**일관성**
- 다중 컴포넌트의 트랜잭션을 조율하지만 관련된 컴포넌트의 상태는 궁극적으로 일관성을 갖는다.
- 부적절한 애그리게이트 경계를 보상하기 위해 사가를 남용하지 말자. 

#### 프로세스 관리자
목적
- 비즈니스 로직 기반 프로세스를 구현하기 위한 것
정의
- 시퀀스의 상태를 유지하고 다음 처리 단계를 결정하는 중앙 처리 장치 (사가에 올바른 동작 과정을 선택하는 if-else문를 넣은 버전이라고 생각해도 좋을 듯 하다. )
차이점 
- 사가: 특정 이벤트가 관찰될 때 암시적으로 인스턴스화 된다.
- 프로세스 관리자: 단일 소스 이벤트에 바인딩 X, 여러 단계로 구성된 응집된 비즈니스 프로세스. 명시적 인스턴스화 필요
구현
- 상태 기반 애그리게이트
- 이벤트 소싱 애그리게이트
- 프로세스 관리자는 워크플로를 제어하는 이벤트를 구독, 실제 커맨드를 실행하기 위해 아웃박스 릴레이에서 처리될 이벤트 CommandIssueEvent를 인스턴스화

예시: 출장 예약
- 사가의 예시와 다르게 출장 예약 프로세스를 트리거하는 중앙 엔티티가 없다. 출장 예약은 프로세스이며, 프로세스 관리자로 구현해야 한다. 

두 패턴 모두 도메인 이벤트에 대한 비동기식 반응과 커맨드 실행에 의존한다. 
